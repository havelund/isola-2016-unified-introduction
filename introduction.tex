
\section{Introduction}
\label{sec:introduction}

Over the last several decades we have observed the development of 
a large collection of specification and modeling languages and 
associated methodologies, and tools. Their purpose is to 
support modeling of requirements and high-level designs before 
programming is initiated. Agile approaches advocate to avoid 
explicit modeling entirely and suggest to go directly to coding. 
Other approaches advocate avoiding manual “coding” in a 
programming 
language entirely and suggest instead the generation of code 
directly from the models. This way modeling languages replace 
programming languages.  We can divide these modeling languages 
into formal specification languages (formal methods), usually 
focusing on textual languages based on mathematical logic and set 
theory, and associated proof tools (theorem provers, model 
checkers, etc.), and on the other hand model-based engineering 
languages (UML, SysML, Modelica, Mathematica, …), focusing more on 
d esign, code generation and simulation. Many of these modeling 
languages have similarities with programming languages.In parallel, and frankly seemingly independent, we have seen the 
development of numerous new programming languages. Few languages 
have had the success of C, which still today is the main 
programming language for embedded systems. The success is so 
outstanding that nearly no progress wrt. praxis has been made in 
this domain (embedded programming) since the 1970ties.  In 
application programming a collection of new languages came ago 
such as Ada, C++, Eiffel etc. At the same time we have seen 
several high-level languages appear targeting the softer side of 
software engineering (such as web-programming, user interfaces, 
scripting), including languages such as Java, JavaScript, Ruby, 
Python and Scala.  More academic languages include Haskell and the 
ML family, including OCaml.

A closer look shows that a tight integration between specification and verification logic, programming languages, and graphical modeling notations as well as modeling concepts is needed. It is the goal of the track to discuss the relationship between modeling and programming, with the possible objective of achieving an agreement of what a unification of these concepts would mean at an abstract level, and what it would bring as benefits on the practical level. What are the trends in the three domains:  
formal specification and verification, 
model-based engineering, and programming, which can be considered to be unifying these domains. Is the time is ripe for another attempt to bring things closer together?

This paper is organized as follows.
In Section \ref{sec:trends} we give a brief overview of some 
of the trends in formal specification, model-based programming and system engineering, and programming, that we consider 
important. 
Section \ref{sec:contributions} presents the papers presented at the track, and included in these proceedings.
Finally Section \ref{sec:conclusion} outlines
brief discussion points to be reflected on
when considering a unified approach, as well
as a conclusion.
